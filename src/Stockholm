#! ../venv/bin/python3
from distutils import extension
from importlib.resources import path
from pkgutil import extend_path
import random
import string
from banner.banner_ import logo
from args.args import ft_args
from clear.clear import clear
import sys, time, os, getpass, argparse
from cryptography.fernet import Fernet


class stockholm(object):
    # Constructor
    extensiones = [".docx", ".ppam", ".sti", ".vcd", ".3gp", ".sch", ".myd", ".wb2 ", ".docb", ".potx", ".sldx", ".jpeg",
                    ".mp4", ".dch", ".frm", ".slk ", ".docm", ".potm", ".sldm", ".jpg", ".mov", ".dip", ".odb", ".dif ", ".dot",
                    ".pst", ".sldm", ".bmp", ".avi", ".pl", ".dbf", ".stc ", ".dotm", ".ost", ".vdi", ".png", ".asf", ".vb",
                    ".db", ".sxc ", ".dotx", ".msg", ".vmdk", ".gif", ".mpeg", ".vbs", ".mdb", ".ots ", ".xls", ".eml", ".vmx",
                    ".raw", ".vob", ".ps1", ".accdb", ".ods ", ".xlsm", ".vsd", ".aes", ".tif", ".wmv", ".cmd", ".sqlitedb",
                    ".max ", ".xlsb", ".vsdx", ".ARC", ".tiff", ".fla", ".js", ".sqlite3", ".3ds ", ".xlw", ".txt", ".PAQ",
                    ".nef", ".swf", ".asm", ".asc", ".uot ", ".xlt", ".csv", ".bz2", ".psd", ".wav", ".h", ".lay6", ".stw",
                    ".xlm", ".rtf", ".tbk", ".ai", ".mp3", ".pas", ".lay", ".sxw ", ".xlc", ".123", ".bak", ".svg", ".sh",
                    ".cpp", ".mml", ".ott ", ".xltx", ".wks", ".tar", ".djvu", ".class", ".c", ".sxm", ".odt ", ".xltm", ".wk1",
                    ".tgz", ".m4u", ".jar", ".cs", ".otg", ".pem ", ".ppt", ".pdf", ".gz", ".m3u", ".java", ".suo", ".odg",
                    ".p12 ", ".pptx", ".dwg", ".7z", ".mid", ".rb", ".sln", ".uop", ".csr ", ".pptm", ".onetoc2", ".rar",
                    ".wma", ".asp", ".ldf", ".std", ".crt ", ".pot", ".snt", ".zip", ".flv", ".php", ".mdf", ".sxd", ".key ",
                    ".pps", ".hwp", ".backup", ".3g2", ".jsp", ".ibd", ".otp", ".pfx ", ".ppsm", ".602", ".iso", ".mkv",
                    ".brd", ".myi", ".odp", ".der ", ".ppsx", ".sxi"]  # List of extensions to be encrypted and decrypted

    def __init__(self): # Constructor of the class (self is the object itself)
        self.clear() # Clear the terminal
        self.slowprint(logo) # Print the banner
        self.args = ft_args()
        self.key = self.keygen() # Generate the key
        self.key_save() # Save the key
        self.crypt = None
        self.files = [] # List of files to be encrypted and decrypted

    def clear(self):
        clear()

    def keygen(self):
        s = input("Quiere generar una clave automaticamente ? (s/n): ")
        if (s == "s" or s == "S"):
            key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(42)) # Generate a random key of 16 characters long
            self.key = key
        elif (s == "n" or s == "N"):
            key = self.key_load()
        else:
            self.clear()
           # self.slowprint(logo)
            print("\n ingresa una opción válida!! \n")
            self.keygen()
        return self.key

    def key_load(self):
        key = getpass.getpass("\nLa clave debe tener 16 caracteres o más:  ") # Get the key from the user and save it in a variable
        if len(key) < 16:
            self.clear()
            #self.slowprint(logo)
            print("\n ingresa una clave válida!! >= a 16 caracteres: \n")
            self.key_load() # Recursive call to the function esto es recursividad lol xd
        self.key = key



    def slowprint(self, n):
        for word in n + '\n':
            sys.stdout.write(word)
            sys.stdout.flush()
            time.sleep(0.0033)

    def key_save(self):
        s = input("\nQuiere guardar la clave en un archivo? (s/n): ")
        if (s == "s" or s == "S"):
            f = open(".key.txt", "w")
            f.write(self.key)
            f.close()
            path =  os.path.join(os.path.dirname(__file__), ".key.txt")
            self.clear()
           # self.slowprint(logo)
            self.slowprint("\nla ruta absoluta de la clave es: " + path)
            self.slowprint("\nKey saved successfully \n")
        elif (s == "n" or s == "N"):
            self.slowprint("\nKey not saved \n")
            time.sleep(0.0021)
        else:
            self.clear()
            print("\n ingresa una opción válida!! \n")
            self.key_save() # Recursive call to the function esto es recursividad lol xd
        #time.sleep(0.019) # Wait 0.019 seconds to continue
        #self.clear() # Clear the terminal
    def encrypt_files(self):
        print("encripando archivos\n")

    def decrypt_files(self):
        print("\nDecrypting files...")


########################################################################################################################

#os.rename('archivo.txt', 'dir') # renombrar archivos
stockholm = stockholm()

def main():

    stockholm.encrypt_files()

if __name__ == "__main__":
    main()
