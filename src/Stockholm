#! ../venv/bin/python3
from crypt import crypt
from distutils import extension
from importlib.resources import path
from pkgutil import extend_path
import random
import string
from banner.banner_ import logo
from args.args import ft_args
from clear.clear import clear
import sys, time, os, getpass, argparse
from cryptography.fernet import Fernet


class stockholm(object):
    # Constructor
    extensiones = [".docx", ".ppam", ".sti", ".vcd", ".3gp", ".sch", ".myd", ".wb2 ", ".docb", ".potx", ".sldx", ".jpeg",
                    ".mp4", ".dch", ".frm", ".slk ", ".docm", ".potm", ".sldm", ".jpg", ".mov", ".dip", ".odb", ".dif ", ".dot",
                    ".pst", ".sldm", ".bmp", ".avi", ".pl", ".dbf", ".stc ", ".dotm", ".ost", ".vdi", ".png", ".asf", ".vb",
                    ".db", ".sxc ", ".dotx", ".msg", ".vmdk", ".gif", ".mpeg", ".vbs", ".mdb", ".ots ", ".xls", ".eml", ".vmx",
                    ".raw", ".vob", ".ps1", ".accdb", ".ods ", ".xlsm", ".vsd", ".aes", ".tif", ".wmv", ".cmd", ".sqlitedb",
                    ".max ", ".xlsb", ".vsdx", ".ARC", ".tiff", ".fla", ".js", ".sqlite3", ".3ds ", ".xlw", ".txt", ".PAQ",
                    ".nef", ".swf", ".asm", ".asc", ".uot ", ".xlt", ".csv", ".bz2", ".psd", ".wav", ".h", ".lay6", ".stw",
                    ".xlm", ".rtf", ".tbk", ".ai", ".mp3", ".pas", ".lay", ".sxw ", ".xlc", ".123", ".bak", ".svg", ".sh",
                    ".cpp", ".mml", ".ott ", ".xltx", ".wks", ".tar", ".djvu", ".class", ".c", ".sxm", ".odt ", ".xltm", ".wk1",
                    ".tgz", ".m4u", ".jar", ".cs", ".otg", ".pem ", ".ppt", ".pdf", ".gz", ".m3u", ".java", ".suo", ".odg",
                    ".p12 ", ".pptx", ".dwg", ".7z", ".mid", ".rb", ".sln", ".uop", ".csr ", ".pptm", ".onetoc2", ".rar",
                    ".wma", ".asp", ".ldf", ".std", ".crt ", ".pot", ".snt", ".zip", ".flv", ".php", ".mdf", ".sxd", ".key ",
                    ".pps", ".hwp", ".backup", ".3g2", ".jsp", ".ibd", ".otp", ".pfx ", ".ppsm", ".602", ".iso", ".mkv",
                    ".brd", ".myi", ".odp", ".der ", ".ppsx", ".sxi"]  # List of extensions to be encrypted and decrypted

    def __init__(self): # Constructor of the class (self is the object itself)
        self.clear() # Clear the terminal
        self.slowprint(logo) # Print the banner
        self.args = ft_args()
        self.key = self.keygen() # Generate the key
        self.key_save() # Save the key
        self.path_files() # Create the directory

    def clear(self):
        clear()

    def keygen(self):
        s = input("Quiere generar una clave automaticamente ? (s/n): ")
        if (s == "s" or s == "S"):
            key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(42)) # Generate a random key of 16 characters long
            self.key = key
        elif (s == "n" or s == "N"):
            key = self.key_load()
        else:
            self.clear()
           # self.slowprint(logo)
            print("\n ingresa una opción válida!! \n")
            self.keygen()
        return self.key

    def key_load(self):
        key = getpass.getpass("\nLa clave debe tener 16 caracteres o más:  ") # Get the key from the user and save it in a variable
        if len(key) < 16:
            self.clear()
            #self.slowprint(logo)
            print("\n ingresa una clave válida!! >= a 16 caracteres: \n")
            self.key_load() # Recursive call to the function esto es recursividad lol xd
        self.key = key
        return self.key

    def slowprint(self, n):
        for word in n + '\n':
            sys.stdout.write(word)
            sys.stdout.flush()
            time.sleep(0.0033)

    def print_key(self):
        a = input("Quieres ver la clave ? (s/n): ")
        if (a == "s" or a == "S"):
            print("\nLa clave es: " + self.key + "\n")
        elif (a == "n" or a == "N"):
            pass
        else:
            self.clear()
            print("\n ingresa una opción válida!! \n")
            self.print_key()

    def key_save(self):
        s = input("\nQuiere guardar la clave en un archivo? (s/n): ")
        if (s == "s" or s == "S"):
            f = open(".key.txt", "w")
            f.write(self.key)
            f.close()
            path =  os.path.join(os.path.dirname(__file__), ".key.txt")
            self.clear()
           # self.slowprint(logo)
            self.slowprint("\nla ruta absoluta de la clave es: " + path)
            self.slowprint("\nKey saved successfully \n")
        elif (s == "n" or s == "N"):
            self.slowprint("\nKey not saved \n")
            time.sleep(0.0021)
        else:
            self.clear()
            print("\n ingresa una opción válida!! \n")
            self.key_save() # Recursive call to the function esto es recursividad lol xd
        #time.sleep(0.019) # Wait 0.019 seconds to continue
        #self.clear() # Clear the terminal
    def ft_extension(self): # funcion para cambiar la extension de los archivos a encriptarq
        pass

    def encrypt_files(self):
        pass
        if self.args.silent == False :
            print("\nEncrypting files...\n")
        print ("\nno se como hacer esto xd lol xdda pero sabre que hacer xd")

    def decrypt_files(self):
        print("\nDecrypting files...\n")

    def path_files(self):
        self.print_key()
        if os.path.isdir(os.path.expanduser('~') + "/infection") == True:
            if self.args.reverse == True:
              self.decrypt_files()
            else:
              self.encrypt_files()
        else:
            print('No existe el directorio:', os.path.expanduser("~")+'/infection\n')
            print('Creamos el directorio\n')
            os.mkdir(os.path.expanduser("~")+'/infection')
            print('Directorio creado\n')
            self.path_files() # Recursive call to the function esto es recursividad lol xd



########################################################################################################################
stockholm = stockholm()


def main():
    pass

if __name__ == "__main__":
    main()

































































